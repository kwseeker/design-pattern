## Java 设计模式

理解 Java 设计模式对理解 JavaWeb 框架比较重要。

学习每种设计模式都要关注其设计思想、类图、应用场景。  
还要关注设计模式之间的关系。  

#### 创建型模式

+ **singleton 单例模式**

+ **factoryMethod 工厂方法模式**

+ **abstractFactory 抽象方法模式**

+ builder 建造者模式

+ prototype 原型模式

#### 结构型模式

+ **adapter 适配器模式**

+ bridge 桥接模式

+ composite 组合模式

+ **decorator 装饰模式**

+ facade 外观模式

+ flyWeight 享元模式

+ **proxy 代理模式**

    代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的引用。它使得客户不能直接与真正的目标对象通信。代理对象是目标对象的代表，
    其他需要与这个目标对象打交道的操作都是和这个代理对象在交涉。      
    代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的，同时也在一定程度上面减少了系统的耦合度。  
    
    个人感觉更通俗的讲就是把边缘性的逻辑加在一个代理人身上，不要烦被代理类，保持被代理类工作的单纯性。类似于 Programmer 和 SPM 的关系。
    
    通过代理模式将两种关联不大的逻辑代码分离开来。

    Spring AOP就是使用代理模式实现的。从而实现非侵入性设计。  
    
    - 动态代理
    相对于静态代理优势：  
    动态代理可以避免大量的代码重复（自动生成这一步满足了这个条件）；  
    动态代理避免了接口修改的时候造成的代理类的修改；  
    动态代理可以代理大量不同种类的对象，但是静态代理只能代理一种类型的对象。  
    
    - 静态代理
    
#### 行为型模式

+ visitor 访问者模式

+ **template 模板模式**

+ **strategy 策略模式**

+ **state 状态模式**

+ **observer 观察者模式**

+ memento 备忘录模式

+ mediator 中介者模式

+ iterator 迭代器模式

+ interpreter 解释器模式

+ **command 命令模式**

+ chainOfResponsibility 责任链模式

## 设计原则（6）

#### 单一职责

#### 里氏替换原则

#### 依赖倒置原则

#### 接口隔离原则

#### 迪米特法则（最少知道原则）

#### 开闭原则（Open Close Principle）   