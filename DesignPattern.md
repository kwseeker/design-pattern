## Java 设计模式

理解 Java 设计模式对理解 JavaWeb 框架比较重要。

学习每种设计模式都要关注其设计思想、类图、应用场景。  
还要关注设计模式之间的关系。  

#### 创建型模式

+ **singleton 单例模式**

+ **factoryMethod 工厂方法模式**

+ **abstractFactory 抽象方法模式**

+ builder 建造者模式

+ prototype 原型模式

#### 结构型模式

+ **adapter 适配器模式**

+ bridge 桥接模式

+ composite 组合模式

+ **decorator 装饰模式**

+ facade 外观模式（门面模式）

    要求一个子系统的外部与其内部的通信必须通过一个统一的对象。
    okhttpClient就是使用的门面模式。okhttpClient包含了post，url等对象。

    Slf4j 中使用的是外观模式，不是代理模式。
    
    Facade外观模式、proxy代理模式、mediator中介者模式的区别：

+ flyWeight 享元模式

+ **proxy 代理模式**

    代理模式分类：  
    
    - 静态代理
    
        代理对象保持被代理对象的引用，代理对象的方法调用被代理对象的方法。  
        静态代理不方便业务拓展，被代理对象拓展了业务，代理对象的代码也要响应的做出修改。
    
    - 动态代理（针对上面问题的改进型）  
        
        使用反射的机制生成一个继承被代理类的动态代理类，然后使用这个生成的动态代理类
        实现业务逻辑。
        
        动态代理的原理（字节码重组）：  
        1 拿到被代理对象的引用，并且反射获取它的所有接口  
        2 JDK Proxy 重新生成一个新的类，同时新的类要实现被代理类所有实现方法（方法内部还是通过反射调用愿对象的方法）  
        3 动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用  
        4 重新编译新生成的Java代码.class （com.sun.proxy.$Proxy0 这个是运行时动态生成的，可以通过反编译工具查看代码）
        5 再重新加载到JVM中运行
        
        相对于静态代理优势：    
        动态代理避免了接口修改的时候造成的代理类的修改；  
        动态代理可以代理大量不同种类的对象，静态代理只能代理一种类型的对象。
    
    动态代理和静态代理最大的不同：静态代理在代理之前需要知道被代理对象所有的信息（通常是持有被调离对象的实例引用）；
    而动态代理不需要知道被代理类的信息，而是代理时通过反射获取被代理对象的信息（可以使用JDK反射或者使用CGLib实现）。
    
    代理模式的优点：
    
    - 解耦
    
    代理模式使用案例：  
    
    - Spring AOP
    - 拦截器 
    
    Spring AOP 代理实现原理？
   
#### 行为型模式

+ visitor 访问者模式

+ **template 模板模式**

+ **strategy 策略模式**

+ **state 状态模式**

+ **observer 观察者模式**

+ memento 备忘录模式

+ mediator 中介者模式

+ iterator 迭代器模式

+ interpreter 解释器模式

+ **command 命令模式**

+ chainOfResponsibility 责任链模式

    Web框架中这种模式的应用还是挺多的。

    责任链模式讲的就是将请求的发送者和接收者进行分离，避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，
    并且沿着这条链传递请求，直到有对象处理它为止，面对需求变更，只需要更加处理类就好了，而且客户端可以按照自己的需求拼接处理链条。  
    (每个处理器是链表的一个节点，所有处理器连成一条链，请求从第一个处理器开始处理(处理器内部决定要不要处理这个请求))。
    
    优点：  
    责任链模式将请求和处理分开，请求者不知道是谁处理的，处理者可以不用知道请求的全貌。  
    提高系统的灵活性。  
    
    缺点：  
    降低程序的性能。每个请求都是从链头遍历到链尾，当链比较长的时候，性能会大幅下降。  
    不易于调试。由于该模式采用了类似递归的方式，调试的时候逻辑比较复杂。
    
    使用限制：
    被处理的对象的处理模式固定，如果每次来的对象的处理方式经常变就不适合用责任链，不然每次都要添加新的处理器节点，还降低性能。
    
    使用案例：
    
    - Spring MVC Filter/Interceptor，Spring Security 的认证链
    - Netty 的 ChannelHandler 应该也是
    
## 设计原则（6）

#### 单一职责

#### 里氏替换原则

#### 依赖倒置原则

#### 接口隔离原则

#### 迪米特法则（最少知道原则）

#### 开闭原则（Open Close Principle）   