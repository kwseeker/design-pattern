## Java 设计模式

理解 Java 设计模式对理解 JavaWeb 框架比较重要。

学习每种设计模式都要关注其设计思想、类图、应用场景。  
还要关注设计模式之间的关系。  

#### 创建型模式

+ **singleton 单例模式**

+ **factoryMethod 工厂方法模式**

+ **abstractFactory 抽象方法模式**

+ builder 建造者模式

+ prototype 原型模式

#### 结构型模式

+ **adapter 适配器模式**

+ bridge 桥接模式

+ composite 组合模式

+ **decorator 装饰模式**

+ facade 外观模式（门面模式）

    要求一个子系统的外部与其内部的通信必须通过一个统一的对象。
    okhttpClient就是使用的门面模式。okhttpClient包含了post，url等对象。

    Slf4j 中使用的是外观模式，不是代理模式。
    
    Facade外观模式、proxy代理模式、mediator中介者模式的区别：

+ flyWeight 享元模式

+ **proxy 代理模式**

    代理模式分类：  
    
    - 静态代理
    
        代理对象保持被代理对象的引用，代理对象的方法调用被代理对象的方法。  
        静态代理不方便业务拓展，被代理对象拓展了业务，代理对象的代码也要响应的做出修改。
    
    - 动态代理（针对上面问题的改进型）  
        
        使用反射的机制生成一个继承被代理类的动态代理类，然后使用这个生成的动态代理类
        实现业务逻辑。
        
        动态代理的原理（字节码重组）：  
        1 拿到被代理对象的引用，并且反射获取它的所有接口  
        2 JDK Proxy 重新生成一个新的类，同时新的类要实现被代理类所有实现方法（方法内部还是通过反射调用愿对象的方法）  
        3 动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用  
        4 重新编译新生成的Java代码.class （com.sun.proxy.$Proxy0 这个是运行时动态生成的，可以通过反编译工具查看代码）
        5 再重新加载到JVM中运行
        
        相对于静态代理优势：    
        动态代理避免了接口修改的时候造成的代理类的修改；  
        动态代理可以代理大量不同种类的对象，静态代理只能代理一种类型的对象。
    
    动态代理和静态代理最大的不同：静态代理在代理之前需要知道被代理对象所有的信息（通常是持有被调离对象的实例引用）；
    而动态代理不需要知道被代理类的信息，而是代理时通过反射获取被代理对象的信息（可以使用JDK反射或者使用CGLib实现）。
    
    代理模式的优点：
    
    - 解耦
    
    代理模式使用案例：  
    
    - Spring AOP
    - 拦截器 
    
    Spring AOP 代理实现原理？
   
#### 行为型模式

+ visitor 访问者模式

+ **template 模板模式**

+ **strategy 策略模式**

+ **state 状态模式**

+ **observer 观察者模式**

+ memento 备忘录模式

+ mediator 中介者模式

+ iterator 迭代器模式

+ interpreter 解释器模式

+ **command 命令模式**

+ chainOfResponsibility 责任链模式

## 设计原则（6）

#### 单一职责

#### 里氏替换原则

#### 依赖倒置原则

#### 接口隔离原则

#### 迪米特法则（最少知道原则）

#### 开闭原则（Open Close Principle）   